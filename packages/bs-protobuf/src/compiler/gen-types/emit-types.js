import { bsProtobufPackage } from "./emit-constants";
import { emitPackagePass1 } from "./emit-pass1";
import { emitPackagePass2 } from "./emit-pass2";
import { specialModuleTypes } from "./resolver";

export async function emitTypes(stream, resolver) {
  emitPrologue(stream, resolver);
  emitPackagePass1(stream, resolver);
  emitBetweenPasses(stream, resolver);
  emitPackagePass2(stream, resolver);
  emitEpilogue(stream, resolver);
}

function emitPrologue(stream, resolver) {
  stream.write(`\
// Generated by protores from @reproto/bs-protobuf, PLEASE EDIT WITH CARE
type protoJs = unit
@module() @val external protoJs: protoJs = "${resolver.options.protoJsPath}"
type serviceRoot
@module("@reproto/bs-protobuf") external _createServiceRoot: _ => serviceRoot = "createServiceRoot"
let createServiceRoot = () => _createServiceRoot(protoJs)
type rec protoStreamNext<'req> = ${bsProtobufPackage}.MethodWrapper.protoStreamNext<'req>
type rec protoStreamCallback<'res> = ${bsProtobufPackage}.MethodWrapper.protoStreamCallback<'res>
let methodWrapper = ${bsProtobufPackage}.MethodWrapper.methodWrapper
module ${specialModuleTypes} = {
`);
  // Noting the options for es5 and es6 generated protobufjs outputs.
  // es5:
  // @module() @val external protoJs: protoJs = "${resolver.options.protoJsPath}"
  // es6:
  // @module("${resolver.options.protoJsPath}") @val external protoJs: protoJs = "default"
}

function emitBetweenPasses(stream, resolver) {
  stream.write(`}
`);
}

function emitEpilogue(stream, resolver) {}
