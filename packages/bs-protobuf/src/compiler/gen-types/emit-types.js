import { bsProtobufPackage } from "./emit-constants";
import { emitPackagePass1 } from "./emit-pass1";
import { emitPackagePass2 } from "./emit-pass2";
import { specialModuleTypes } from "./resolver";

export async function emitTypes(stream, resolver) {
  emitPrologue(stream, resolver);
  emitPackagePass1(stream, resolver);
  emitBetweenPasses(stream, resolver);
  emitPackagePass2(stream, resolver);
  emitEpilogue(stream, resolver);
}

function emitPrologue(stream, resolver) {
  stream.write(`\
// Generated by protores from @reproto/bs-protobuf, PLEASE EDIT WITH CARE
type protoJs = unit
`);
  emitProtoModuleDirective(stream, resolver);
  stream.write(`@val external protoJs: protoJs = "default"
type serviceRoot
@module("@reproto/bs-protobuf") external _createServiceRoot: _ => serviceRoot = "createServiceRoot"
let createServiceRoot = () => _createServiceRoot(protoJs)
type rec protoStreamNext<'req> = ${bsProtobufPackage}.MethodWrapper.protoStreamNext<'req>
type rec protoStreamCallback<'res> = ${bsProtobufPackage}.MethodWrapper.protoStreamCallback<'res>
let methodWrapper = ${bsProtobufPackage}.MethodWrapper.methodWrapper
module ${specialModuleTypes} = {
`);
}

function emitBetweenPasses(stream, resolver) {
  stream.write(`}
`);
}

function emitProtoModuleDirective(stream, resolver) {
  stream.write(`@module("${resolver.protoJsPath}") `);
}

function emitEpilogue(stream, resolver) {}
